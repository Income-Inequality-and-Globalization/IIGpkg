% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/02_gibbs_sampler_core_SM_mod02.R
\name{GibbsSSM_2}
\alias{GibbsSSM_2}
\title{Title}
\usage{
GibbsSSM_2(
  itermax = 15000,
  identmax = 5000,
  npara,
  nreg,
  njointfac,
  yObs,
  c_,
  D,
  D0,
  B,
  Phi,
  Q,
  type = "allidio",
  initX,
  initP,
  initU,
  wRegSpec,
  wReg,
  uReg = NULL,
  B0,
  Omega0,
  selectR,
  selectC,
  Vhat,
  incObsOld = 1e+05,
  incObsNew = 1e+05,
  covScale,
  VhatDiagScale,
  VhatDiagScale_start = NULL,
  VdiagEst,
  alpha0,
  beta0,
  countryA,
  A,
  scaleA,
  diagA,
  Psi0,
  nu0,
  shape0,
  rate0,
  storePath = "none",
  fPost,
  sampleA,
  identification = T,
  storeUnit = 10000
)
}
\arguments{
\item{itermax}{Number of Gibbs iterations}

\item{identmax}{Nicht mehr noetig (war fuer altes Sampling proceduere - so lange samplen bis Parameterrestriktionen eingehalten)}

\item{npara}{Anzahl der Parameter (bei uns immer 3)}

\item{nreg}{Anzahl der  Regressoren (1 bis 3)}

\item{njointfac}{Anzahl der gemeinsamen Faktoren (zuletzt immer 0)}

\item{yObs}{Daten (a, q, mu)}

\item{c_}{Konstante der Transition-equation (keine Konstante im Modell - daher nicht relevant)}

\item{D}{Startwert fuer die Koeffizienten der Regressorn (stacked: npara*N x nreg*N), N = Anzahl Laender}

\item{D0}{Prior Erwwartungswert fuer die Koeffizienten der Makro- Regressoren (bei mir immer gleich dem Starwert, da ich beides mit makeDstart erzeuge. Aber nicht stacked, sondern npara x nreg x N Array)}

\item{B}{Startwerte fuer die Ladungen auf die latenten Faktoren (stacked: npara *N x #Faktoren)}

\item{Phi}{Koeffizentenmatrix des State-Prozesses (bei unser immer diag(#Faktoren), random walks)}

\item{Q}{Felhervarianz des State-Prozesses (bi uns immer auf diag(#Faktoren) gesetzt)}

\item{type}{Modelltyp: Auswahls aus "allidio","countryidio", "countryidio_nomu". Bei uns immer "allidio", d.h. jeder Paramter (jeden Landes) bekommt eigenen idiosynkr. Faktor. Hatte auch mal ausprobiert, dass z.B. nur jedes Land einen bekommt.}

\item{initX}{Initialsierung der States im KF. Bei uns immer rep(0, #Faktoren)}

\item{initP}{Intitalisierung der State-Varianz im KF. Bei uns immer diag(0, #Faktoren)}

\item{initU}{Initialisierung der Regressoren in der State-Prozess. Für uns irrelevant, darf im KF aber nciht fehlen und wird daher = 0.}

\item{wRegSpec}{Ein Skalar, der angibt, welche Regressoren hinzugefuegt werden. Bei drei Regressoren gibt es 7 Möglichkeiten, also ist wRegSpec eine Zahl von 1-7. Die Moeglichkeiten werden in Gibbs2_SM_SA_cluster berechnet. Es gilt: 1 = "cpi_change", 2 = "unemployment", 3 = "gdp_ppp", 4 = "cpi_change" + "unemployment", 5 = "cpi_change" + "gdp_ppp", 6 = "unemployment" + "gdp_ppp", 7 = "cpi_change" +"unemployment" +"gdp_ppp"}

\item{wReg}{Regressoren für die Messgleichung, also die Makros: nreg * N x T (muss natuerlich zu wRegSpec passen)}

\item{uReg}{Siehe initU. Fuer uns irrelevant, wird gleich NULL gesetzt.}

\item{B0}{Prior Erwwartungswert fuer die Ladungen auf die latenten Fakoren (bei mir immer gleich dem Starwert, da ich beides mit makeBstart erzeuge. Aber nicht stacked, sondern npara x (npara + njointfac) x N Array bei type = "allidio")}

\item{Omega0}{Prior Varianz fuer die Ladungen auf die latenten Fakoren und die Makro-Regressor-Koeffizienten.}

\item{selectR}{Selektionsmatrix: Waehlt Elemente aus vec(B_i), die gesamplet werden sollen. Auf den anderen Elementen liegen Nullrestriktionen}

\item{selectC}{Es wird selectR * vec(B_i) + selectC gesamplet. selectC ist bei uns immer ein Nullvektor, da wir keine affin-lineare Transformation benoetigen.}

\item{Vhat}{QML(bzw. GMM) geschaetzte Fehlervarianz der Vorschaetzung. Ein npara x npara x N * T Array. Die ersten Elemente [1:npara, 1:npara, 1:T] sind die Varianzen des ersten Landes ueber die Zeit, [1:npara, 1:npara, (T+1):(2T)] sind die Varianzen des zweiten Landes ueber die Zeit, usw.}

\item{incObsOld}{Anzahl der Beobachtungen (der Rohdaten, also individuelle Einkommen), die wir in der GMM-Schaetzung angenommen haben. Bei mir 100000. Das ist zu viel. Daher incObsNew.}

\item{incObsNew}{Gewuenschte / Korrigierte Anzahl der Beochbachtungen in der GMM-Schaetzung. Setze bspw. gleich 5000 oder 10000. Das ist realistischer als 100000.}

\item{covScale}{Damit kann man die Kovarianzen aus Vhat skalieren. covScale = 0.5 heißt, dass die die Korrelationen(!) halbiert werden. War mal ein Experiment. covscale muss letztlich = 1 sein.}

\item{VhatDiagScale}{(wahrscheinlich irrelevant) = TRUE, wenn fuer jedes Diagonalelement der GMM- varianz ein Skalierungsfaktor geschaetzt werden soll. In Gibb2_SM_SA_cluster muss dann Diag_VCOV = TRUE gesetzt werden, damit die Nebendiagonalelemente der GMM-Varianz = 0 gesetzt werden. Wenn VDiagScale = TRUE sein soll, muss auch VDiagEst = TRUE sein.}

\item{VhatDiagScale_start}{Startwert fuer die Skalierungsfaktoren}

\item{VdiagEst}{(wahrscheinlich irrelevant) = TRUE, wenn die diagonale Messfehlervarianz geschaetzt werden soll. (Fuer uns irrelevant, wir wollen die GMM-Varianz nutzen)}

\item{alpha0}{Prior-Shape-Paramter fuer Inverse-Gamma(!), wenn VdiagEst = TRUE}

\item{beta0}{Prior-Scale-Paramter fuer Inverse-Gamma(!), wenn VdiagEst = TRUE}

\item{countryA}{= TRUE, wenn fuer jedes Land eine eigene Adjustmentmatrix (der GMM-Varianz) A geschaetzt werden soll}

\item{A}{Startwert fuer A, bei mir immer diag(npara)}

\item{scaleA}{=TRUE, wenn die Matrix A nur ein Skalar sein soll.}

\item{diagA}{= TRUE, wenn die Matrix A eine Diagonalmatrix sein soll}

\item{Psi0}{Prior-Paramter der Inverse-Wishart (wenn A eine vollbesetzte Matrix ist)}

\item{nu0}{Prior-Paramter der Inverse-Wishart (wenn A eine vollbesetzte Matrix ist)}

\item{shape0}{Prior-Shape-Paramter fuer Inverse-Gamma(!), wenn diagA = TRUE oder scaleA = TRUE}

\item{rate0}{Prior-Scale-Paramter fuer Inverse-Gamma(!), wenn diagA = TRUE oder scaleA = TRUE}

\item{storePath}{Speicherpfad des .rds Outputs. Muss nur der Oberordner sein. Es werden automatisch Unterordner mit entpsrechenden Ordnernamen angelegt. Setze = "none", wenn nichts gespeichert werden soll.}

\item{fPost}{Kann angegeben werden, wenn FFBS ausgelassen werden soll und man gegeben fester Faktoren samplen möchte. fPost muss dann #Faktoren x T sein. Wenn es fehlt, wird FFBS durchgefuehrt.}

\item{sampleA}{= TRUE, wenn A gesamplet werden soll (bei uns immer der Fall). Bei sampleA = FALSE, muss trotzdem das A Argument = diag(npara) gesetzt werden.}

\item{identification}{(Kann ignoriert werden) Boolscher Wert der dazu diente, um identifizierende Restriktionen zu ignorieren. Jetzt werde diese immer eingehalten.}

\item{storeUnit}{Zahl. Alle storeUnit-Iterationen werden die Zwischenergebnisse gespeichert.}
}
\description{
Title
}
